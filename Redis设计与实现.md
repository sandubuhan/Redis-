# Redis设计与实现

## 第二章 简单动态字符串（String）

+ Redis构建了一种名为简单动态字符串（SDS）的抽象类型，并将SDS用作Redis的默认字符串表示
+ 当Redis需要的不仅是一个字符串字面量，而是一个可以被修改的字符串值时，就会使用SDS来表示字符串值。
+ 比如

~~~shell
redis> RPUSH fruits "apple" "banana"
~~~

+ Redis将在数据库中创建一个新的键值对，其中：
    + 键值对的键是一个字符串对象，底层实现是一个保存了字符串“fruits”的SDS
    + 值是一个列表对象，包含了两个字符串对象。这两个对象分别由两个SDS实现。
+ 除此外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区

###  SDS的定义

![image-20220614213514317](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142135641.png)

+ free：表示这个SDS未分配的空间
+ len：表示保存的空间
+ buf：是一个char类型的数组，最后一个字节保存了空字符“\0"
+ 保存空字符的1字节空间不计算在SDS的len属性里，并且为空字符分配额外的1字节空间

### SDS与字符串的区别

+ C语言顺颂的字符串表达方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求

### 常数复杂度获取字符串长度

+ 因为有len属性， 所以获取一个SDS长度的复杂度仅为O(1)。设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无需进行任何手动修改长度的工作

### 杜绝缓冲区溢出

+ 除了获取字符串长度的复杂度高之外，C 字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出。
+ 而当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出

### 减少修改字符串时带来的内存重分配次数

+ 因为不记录自身长度，所以C字符串在增长或者缩短一个C字符串时，程序都要到对保存这个C字符串的数字进行一次内存重分配操作
+ SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录
+ 通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。
    + 空间预分配：
    + 当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会对SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间
    + 如果对SDS进行修改之后，SDS的长度（len）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS的len属性的值将和free的值相同
    + 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。
    + 通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数
    + 在扩展SDS空间之前，SDS的API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无需执行内存重分配
    + 使得内存重分配次数从必定N次变成最多N次
    + 惰性空间释放：
    + 当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这批字节的数量记录下来，并等待将来使用
    + 与此同时，SDS也提供了相应的API，让我们可以在有需要的时候，真正的释放SDS未使用的空间，所以不用担心惰性空间释放策略会造成内存浪费

### 二进制安全

+ 因为C字符串中的字符必须符合某种编码（ASCII），并且除了字符串的末位之外，字符串里不能包含空字符，所以C字符串只能保存文本数据，不能保存图片、音视频、压缩文件等二进制数据。
+ 这种二进制数据大多会包含空字符"\0"
+ SDS的API都是二进制安全的：数据在写入时是什么样，被读取时就是什么样

### 兼容部分C字符串函数

### 总结

![image-20220614213536195](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142135655.png)



## 第三章 链表（List）

+ Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现
+ 列表建的底层实现之一就是链表。当一个列表建包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现
+ 除了链表键之外，发布订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区

### 链表和链表节点的实现

+ 链表节点：

![image-20220614001458113](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206140014396.png)

+ 多个listNode通过prev和next指针组成双端链表

+ 链表：

![image-20220614213602068](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142136934.png)

+ 通过list来操作链表
    + 表头指针：head，表尾指针：tail，链表长度计数器：len
    + dup：用于复制链表节点所保存的值
    + free：释放链表节点所保存的值
    + match：对比链表节点所保存的值和另一个输入值是否相等
+ Redis的链表实现的特性：
    + 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置借点的复杂度都是O(1)
    + 无环：表头节点的prev指针和表尾节点的next指针都指向null，对链表的访问以Null为终点
    + 带表头指针和表尾指针：通过list结构的head和tail，程序获取表头表尾的复杂度为O(1)
    + 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，获取链表节点数量的复杂度为O(1)
    + 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存不同类型的值



## 第四章 字典（Hash）

~~~shell
127.0.0.1:6379> hset user name1 hao
(integer) 1
127.0.0.1:6379> hset user email1 hao@163.com
(integer) 1
127.0.0.1:6379> hgetall user
1) "name1"
2) "hao"
3) "email1"
4) "hao@163.com"
127.0.0.1:6379> hget user user
(nil)
127.0.0.1:6379> hget user name1
"hao"
127.0.0.1:6379> hset user name2 xiaohao
(integer) 1
127.0.0.1:6379> hset user email2 xiaohao@163.com
(integer) 1
127.0.0.1:6379> hgetall user
1) "name1"
2) "hao"
3) "email1"
4) "hao@163.com"
5) "name2"
6) "xiaohao"
7) "email2"
8) "xiaohao@163.com"
~~~

+ 又称为符号表、关联数组、映射，是一种用于保存键值对的抽象数据结构
+ 字典中的每个键都是独一无二（key不能重复，value可以重复）
+ C语言没有内置字典，所以Redis构建了自己的字典实现
+ Redis的数据库就是使用字典作为底层实现，对数据库的增删改查操作也是构建在字典的操作之上的

~~~shell
redis> set msg "hello"
ok
~~~

+ 上述命令，，这个键值对就是保存在代表数据库的字典里面的
+ 字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现

### 字典的实现

+ Redis的字典使用哈希表作为底层实现，一个哈希表里面可以由多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对

#### 哈希表

![image-20220614214308013](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142143064.png)

+ table属性是一个数组，数组中的每个元素都是一个指向dictEntry结构的指针，每个dictEntry结构保存着一个键值对
+ size属性记录哈希表大小，也就是table数组的大小
+ sizemask的值总是等于size-1，它和哈希值一起决定一个键被放到table数组的哪个索引上面

#### 哈希表节点

+ 哈希表节点使用dictEntry结构表示

![image-20220614214622717](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142146794.png)

+ next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决键冲突（头插法）

![image-20220614214731826](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142147917.png)

####　字典

![image-20220614214801350](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142148449.png)

+ type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数

![image-20220614214918544](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142149644.png)

+ ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只是用ht[0]哈希表，ht[1]只会在对ht[0]进行rehash时使用
+ rehashid用于记录目前rehash的进度，如果没有rehash，被标记为-1

![image-20220614215101075](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142151177.png)

### 哈希算法

+ 当要将一个新的键值对添加到字典里面，程序需要先根据键值对的键计算出哈希值和索引值，再根据所印制，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面

~~~shell
hash = dict->type->hashFunction(key);
index = hash & dict->ht[x].sizemask;
~~~

+ Redis使用MurmurHash2算法计算键的哈希值

### 解决键冲突

+ 当有两个或以上的键被分配到了哈希表数组的同一个索引上面时，就称为冲突
+ Redis的哈希表使用链地址法解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个车单向链表，被分配到同一个索引上的多个节点可以被连接起来

### rehash

+ 哈希表保存的键值对会随着操作的执行而增多或减少，为了让哈希表的负载因子（[0.75](https://stackoverflow.com/questions/7115445/what-is-the-optimal-capacity-and-load-factor-for-a-fixed-size-hashmap)）维持在一个合理的范围内，当哈希表保存的键值对数量过多或过少，程序会对哈希表的大小进行扩展或者收缩

+ 步骤：
    + 为字典的ht[1]哈希表分配空间
        + 扩展：ht[1]的大小为第一个大于等于ht[0].used*2的"2的n次方幂"
        + 收缩：ht[1]大小为第一个车大于等于ht[0].used的"2的n次方幂"
    + 将保存在ht[0]中的所有键值对rehash到ht[1]上，rehash指重新计算键的哈希值和索引值
    + 当所有的键值对都迁移后，释放ht[0],将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表

### 哈希表的扩展收缩

+ 程序会自动对哈希表扩展：
    + 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令时，并且哈希表的负载因子大于等于1
    + 正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5
+ 公式

~~~shell
# 负载因子 = 哈希表已保存节点数量 / 哈希表大小
load_factor = ht[0].used / ht[0].size
# 已保存节点数量≠桶的数量（数组的大小）
~~~

+ 在执行BGSAVE或者BGREWRITEAOF命令时，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制来优化紫禁城的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子。从而尽可能避免在子进程存在期间进行哈希表扩展操作，可以避免不必要的内存写入操作，最大限度的节约内存
+ 另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表收缩

### 渐进式rehash

+ rehash的动作并不是一次性，而是分多次、渐进式的完成。因为避免庞大的键值对在计算时会对服务器造成影响
+ 在字典中维持索引计数器变量rehashidx，并设置为0，表示rehash工作开始
+ 在rehash期间，每次对字典执行增删改查，程序除了执行指定的操作以外，还会将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]。当rehash 完成后，rehashidx+1
+ 都完成后，rehashidx == -1
+ 渐进式执行期间，新添加到字典的键值对会保存到ht[1]



## 第五章 跳跃表 （Zset）

~~~shell
127.0.0.1:6379> zadd myscoreset 100 hao 90 xiaohao
(integer) 2
127.0.0.1:6379> ZRANGE myscoreset 0 -1
1) "xiaohao"
2) "hao"
127.0.0.1:6379> ZSCORE myscoreset hao
"100"
~~~

+ 跳跃表是一种有序数据结构，支持平均O(logN)，最坏O(N)复杂度的节点查找
+ Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表作为有序集合键的底层实现
+ Redis只在两个地方用到了跳跃表，一个是实现有序集合键，一个是集群节点中用作内部数据结构

### 跳跃表的实现

+ 由zskiplistNode和zskiplist两个结构定义。前者表示跳跃表节点，后者用于保存跳跃表节点的相关信息，比如数量，以及指向表头和表尾节点的指针

![image-20220614234821152](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206142348270.png)

+ zskiplist:
    + level：记录目前跳跃表内，层数最大的节点的层数（表头节点不计算在内）
    + length：记录跳跃表的长度，也就是跳跃表目前包含节点的数量（表头节点不包含）
+ zskiplist:
    + 层level：节点重点用L1、L2等标记节点的各个层，代表第一二层等。每个层都有两个属性：前进指针和跨度。前进指针用于访问位于**表尾方向**的其他节点，跨度是记录了前进指针所指向节点和当前节点的距离。上图，连线上带有数字的箭头就代表前进指针，数字就是跨度。当程序从头到尾遍历时，访问会沿着层的前进指针进行
    + 后退指针bw：指向位于当前节点的前一个节点。在从尾到头遍历时使用
    + 分值score：节点按各自保存的分值从小到大排列
    + 成员对象obj：
+ 表头节点和其他节点的构造是一样的

### 跳跃表节点

1. 层
    + 跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快
    + 每次创建一个新跳跃表节点，程序都根据幂次定律（越大的数出现的概率越小）随机生成一个介于1到32之间的值作为level的大小，就是层的高度

2. 前进指针
    + 每层都有一个指向表尾方向的前进指针

3. 跨度

    + 层的跨度用于记录两个节点之间的距离：

    + 指向null的所有前进指针的跨度都为0，因为没有联想任何节点

+ 跨度和遍历操作并没有关系。遍历操作只使用前进指针，跨度实际上使用来计算排位的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位
+ 例子

![image-20220615000956953](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206150009095.png)

+ 虚线标记了查找3.0的O3对象节点，沿途经历的层：1，层的跨度为3。所以目标节点在跳跃表中排位为3

![image-20220615001049877](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206150010983.png)

+ 查找2.0的O2对象，程序经过了两个跨度为1的节点，所以目标节点在跳跃表中的排位为2

4. 后退指针
    1. 用于从尾到头访问节点，每个节点只有一个后退指针，每次必须后退到前一个节点
5. 分值和成员
    + 跳跃表中的所有节点都按照分值从小到大排序
    + 成员对象是一个指针，指向一个字符串对象，这个对象就是SDS
    + 在同一个表中，每个节点保存的成员对象必须为宜，但是多个节点保存的分值却可以相同：**分值相同的节点按照成员对象在字典序中的大小进行排序**

### 跳跃表

+ 虽然靠多个跳跃表节点就可以组成一个跳跃表
+ 但是通过使用一个zskiplist结构来持有这些节点，程序可以更方便的对整个跳跃表进行处理，比如快速访问表头或者表尾，火哥快速获取跳跃表节点的数量



## 第六章 整数集合 （Set）

+ 整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现

~~~shell
redis> SADD numbers  1 3 5 7 9 
(integer) 5
redis> OBJECT ENCODING  numbers
"intset"
~~~

### 整数集合的实现

+ 整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t,int32_t,int64_t的整数值，并且保证集合中不出现重复元素

![image-20220616221737753](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206162217930.png)

+ contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小从小到大有序的排列，并且数组中不包含重复项
+ 虽然intest结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值

![image-20220616222024770](https://picgo-machuan.oss-cn-hangzhou.aliyuncs.com/reids/202206162220874.png)

+ encoding属性表示整数集合的底层实现为int64_t类型的数组，而数组中保存的都是int64_t类型的整数值
+ length表示包含四个元素
+ contents数组从小到大顺序保存
+ 因为每个集合元素都是int64_t类型的整数值，所以contents数组的大小为64*4=256位
+ 根据整数集合的升级规则，当向一个底层为int16_t数组的证书集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型，所以contents数组保存的四个整数值都是int64_t类型的

### 升级

+ 当将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面
+ [三步](https://juejin.cn/post/6844904198019137550)：
    + 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
    + 将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素房知道正确的位上，在放置的过程中，需要继续维持底层数组的有序性质不变
    + 将新元素添加到底层数组里面
+ 想整数集合添加新元素的时间复杂度为O(N)
+ 因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么大于所有现有元素，要么小于所有现有元素
    + 小于的情况下，新元素会被放置在底层数组的最开头
    + 大于时，会被放在最末尾(索引length-1)

### 升级的好处

+ 提升灵活性
+ 节约内存

### 降级

+ 整数集合不支持降级，一旦对数组进行了升级，编码就会一直保持升级后的状态。



## 压缩列表

