# Redis设计与实现

## 第二章 简单动态字符串（String）

+ Redis构建了一种名为简单动态字符串（SDS）的抽象类型，并将SDS用作Redis的默认字符串表示
+ 当Redis需要的不仅是一个字符串字面量，而是一个可以被修改的字符串值时，就会使用SDS来表示字符串值。
+ 比如

~~~shell
redis> RPUSH fruits "apple" "banana"
~~~

+ Redis将在数据库中创建一个新的键值对，其中：
    + 键值对的键是一个字符串对象，底层实现是一个保存了字符串“fruits”的SDS
    + 值是一个列表对象，包含了两个字符串对象。这两个对象分别由两个SDS实现。
+ 除此外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区

### 2.1 SDS的定义

![202206121718031](https://raw.githubusercontent.com/sandubuhan/PicGo/main/img/202206121732535.png?token=ANCBAXX3ZSBWBR6GCUP4D73CUWZOC)

+ free：表示这个SDS未分配的空间
+ len：表示保存的空间
+ buf：是一个char类型的数组，最后一个字节保存了空字符“\0"
+ 保存空字符的1字节空间不计算在SDS的len属性里，并且为空字符分配额外的1字节空间

## 2.2 SDS与字符串的区别

+ C语言顺颂的字符串表达方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求

### 常数复杂度获取字符串长度

+ 因为有len属性， 所以获取一个SDS长度的复杂度仅为O(1)。设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无需进行任何手动修改长度的工作

### 杜绝缓冲区溢出

+ 除了获取字符串长度的复杂度高之外，C 字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出。
+ 而当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出

### 减少修改字符串时带来的内存重分配次数

+ 因为不记录自身长度，所以C字符串在增长或者缩短一个C字符串时，程序都要到对保存这个C字符串的数字进行一次内存重分配操作
+ SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录
+ 通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。
    + 空间预分配：
    + 当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会对SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间
    + 如果对SDS进行修改之后，SDS的长度（len）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS的len属性的值将和free的值相同
    + 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。
    + 通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数
    + 在扩展SDS空间之前，SDS的API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无需执行内存重分配
    + 使得内存重分配次数从必定N次变成最多N次
    + 惰性空间释放：
    + 当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这批字节的数量记录下来，并等待将来使用
    + 与此同时，SDS也提供了相应的API，让我们可以在有需要的时候，真正的释放SDS未使用的空间，所以不用担心惰性空间释放策略会造成内存浪费

### 二进制安全

+ 因为C字符串中的字符必须符合某种编码（ASCII），并且除了字符串的末位之外，字符串里不能包含空字符，所以C字符串只能保存文本数据，不能保存图片、音视频、压缩文件等二进制数据。
+ 这种二进制数据大多会包含空字符"\0"
+ SDS的API都是二进制安全的：数据在写入时是什么样，被读取时就是什么样

### 兼容部分C字符串函数

### 总结

![202206121720312](https://raw.githubusercontent.com/sandubuhan/PicGo/main/img/202206121732744.png?token=ANCBAXTXJOQWEKDUOLRL7ALCUWZOQ)



## 第三章 链表（list）

+ Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现
+ 列表建的底层实现之一就是链表。当一个列表建包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现
+ 除了链表键之外，发布订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区

### 链表和链表节点的实现

+ 链表节点：

![image-20220612203609649](https://raw.githubusercontent.com/sandubuhan/PicGo/main/img/202206122036738.png?token=ANCBAXRRC5GSEEG3FEBEBT3CUXO7M)

+ 多个listNode通过prev和next指针组成双端链表

+ 链表：

![image-20220612203626152](https://raw.githubusercontent.com/sandubuhan/PicGo/main/img/202206122036222.png?token=ANCBAXU27KLJAWVNPHJXVRDCUXPAO)

+ 通过list来操作链表
    + 表头指针：head，表尾指针：tail，链表长度计数器：len
    + dup：用于复制链表节点所保存的值
    + free：释放链表节点所保存的值
    + match：对比链表节点所保存的值和另一个输入值是否相等
+ Redis的链表实现的特性：
    + 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置借点的复杂度都是O(1)
    + 无环：表头节点的prev指针和表尾节点的next指针都指向null，对链表的访问以Null为终点
    + 带表头指针和表尾指针：通过list结构的head和tail，程序获取表头表尾的复杂度为O(1)
    + 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，获取链表节点数量的复杂度为O(1)
    + 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存不同类型的值



## 第四章 字典（Hash）

