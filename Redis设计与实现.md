# Redis设计与实现

## 第二章 简单动态字符串

+ Redis构建了一种名为简单动态字符串（SDS）的抽象类型，并将SDS用作Redis的默认字符串表示
+ 当Redis需要的不仅是一个字符串字面量，而是一个可以被修改的字符串值时，就会使用SDS来表示字符串值。
+ 比如

~~~shell
redis> RPUSH fruits "apple" "banana"
~~~

+ Redis将在数据库中创建一个新的键值对，其中：
    + 键值对的键是一个字符串对象，底层实现是一个保存了字符串“fruits”的SDS
    + 值是一个列表对象，包含了两个字符串对象。这两个对象分别由两个SDS实现。
+ 除此外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区

### 2.1 SDS的定义



+ free：表示这个SDS未分配的空间
+ len：表示保存的空间
+ buf：是一个char类型的数组，最后一个字节保存了空字符“\0"
+ 保存空字符的1字节空间不计算在SDS的len属性里，并且为空字符分配额外的1字节空间

## 2.2 SDS与字符串的区别

+ C语言顺颂的字符串表达方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求

### 常数复杂度获取字符串长度

+ 因为有len属性， 所以获取一个SDS长度的复杂度仅为O(1)。设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无需进行任何手动修改长度的工作

### 杜绝缓冲区溢出

+ 除了获取字符串长度的复杂度高之外，C 字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出。
+ 而当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出

### 减少修改字符串时带来的内存重分配次数

+ 因为不记录自身长度，所以C字符串在增长或者缩短一个C字符串时，程序都要到对保存这个C字符串的数字进行一次内存重分配操作
+ SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录
+ 通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。
    + 空间预分配：
    + 当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会对SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间
    + 如果对SDS进行修改之后，SDS的长度（len）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS的len属性的值将和free的值相同
    + 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。
    + 通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数
    + 在扩展SDS空间之前，SDS的API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无需执行内存重分配
    + 使得内存重分配次数从必定N次变成最多N次
    + 惰性空间释放：
    + 当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这批字节的数量记录下来，并等待将来使用
    + 与此同时，SDS也提供了相应的API，让我们可以在有需要的时候，真正的释放SDS未使用的空间，所以不用担心惰性空间释放策略会造成内存浪费

### 二进制安全

+ 因为C字符串中的字符必须符合某种编码（ASCII），并且除了字符串的末位之外，字符串里不能包含空字符，所以C字符串只能保存文本数据，不能保存图片、音视频、压缩文件等二进制数据。
+ 这种二进制数据大多会包含空字符"\0"
+ SDS的API都是二进制安全的：数据在写入时是什么样，被读取时就是什么样

### 兼容部分C字符串函数

### 总结



## 第三章 链表

